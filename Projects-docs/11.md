# Architecture

* https://docs.jupyter.org/en/latest/projects/architecture/content-architecture.html

This page has information about the different architectural designs of core pieces in the Jupyter ecosystem. Some of these are individual projects, and others show the relationships between projects.
此页面包含有关 Jupyter 生态系统中核心部分的不同架构设计的信息。其中一些是单独的项目，而另一些则显示了项目之间的关系。

## Projects overview

Below is a high level visual overview of project relationships. It is current as of 2022.
以下是项目关系的高级视觉概述。 截止到 2022 年。

![](https://docs.jupyter.org/en/latest/_images/repos_map.png)

## IPython Kernel

This section focuses on IPython and kernels. When we discuss `IPython`, we talk about two fundamental roles:
本节重点介绍 IPython 和内核。 当我们讨论 IPython 时，我们会讨论两个基本角色：

- Terminal IPython as the familiar REPL
  IPython 作为熟悉的 REPL

- The IPython kernel, `IPykernel` that provides computation and communication with the frontend interfaces, like the notebook
  IPython 内核，提供计算和与前端接口通信的 IPykernel，比如 notebook

### Terminal IPython

When you type `ipython`, you get the original IPython interface, running in the terminal. It does something like this:
当您键入 ipython 时，您将获得在终端中运行的原始 IPython 界面。 它做这样的事情：

```python
while True:
    code = input(">>> ")
    exec(code)
```

Of course, it’s much more complex, because it has to deal with multi-line code, tab completion using `readline`, magic commands, and so on. But the model is like code example: prompt the user for some code, and when they’ve entered it, execute it in the same process. This model is often called a [REPL](https://docs.jupyter.org/en/latest/glossary.html#term-REPL), or Read-Eval-Print-Loop.
当然，它要复杂得多，因为它必须处理多行代码、使用 readline 的制表符补全、魔术命令等。但是这个模型就像代码示例：提示用户输入一些代码，当他们输入代码时，在同一个进程中执行它。该模型通常称为 REPL，或 Read-Eval-Print-Loop。

### The IPython Kernel

All the other interfaces —- the Notebook, the Qt console, `ipython console` in the terminal, and third party interfaces —- use the IPython Kernel. **IPykernel is a separate process which is responsible for running user code, and things like computing possible completions.** Frontends, like the notebook or the Qt console, communicate with the IPython Kernel using JSON messages sent over [ZeroMQ](http://zeromq.org/) sockets; the protocol used between the frontends and the IPython Kernel is described in [Messaging in Jupyter](https://jupyter-client.readthedocs.io/en/latest/messaging.html#messaging "(in jupyter_client v8.2)").
所有其他接口——Notebook、Qt 控制台、终端中的 ipython 控制台和第三方接口——使用 IPython 内核。 IPykernel 是一个独立的进程，负责运行用户代码，以及计算可能的完成等事情。 前端，如笔记本或 Qt 控制台，使用通过 ZeroMQ 套接字发送的 JSON 消息与 IPython 内核通信； 前端和 IPython 内核之间使用的协议在 Jupyter 中的消息传递中进行了描述。

The core execution machinery for the kernel is shared with terminal IPython.
内核的核心执行机制与终端 IPython 共享。

![](https://docs.jupyter.org/en/latest/_images/ipy_kernel_and_terminal.png)

A kernel process can be connected to more than one frontend simultaneously. In this case, the different frontends will have access to the same variables.
一个内核进程可以同时连接到多个前端。 在这种情况下，不同的前端将可以访问相同的变量。

This design was intended to allow easy development of different frontends based on the same kernel, but it also made it possible to support new languages in the same frontends, by developing kernels in those languages, and we are refining IPython to make that more practical.
这种设计旨在允许基于相同内核轻松开发不同的前端，但它也可以通过在这些语言中开发内核来支持相同前端中的新语言，我们正在改进 IPython 以使其更加实用。

Today, there are three ways to develop a kernel for another language:
今天，可以通过三种方式为另一种语言开发内核：

- Wrapper kernels reuse the communications machinery from IPykernel, and implement only the core execution part.
  包装内核重用 IPykernel 中的通信机制，并且只实现核心执行部分。

- Native kernels implement execution and communications in the target language.
  本机内核以目标语言实现执行和通信。

- Kernels based on [xeus](https://github.com/jupyter-xeus/xeus), a native implementation of the protocol, implement the language-specific part of the kernels. Contrary to the wrapper approach, xeus does not depend on a python runtime.
  基于 xeus 的内核，协议的本地实现，实现了内核的语言特定部分。 与包装器方法相反，xeus 不依赖于 python 运行时。

![](https://docs.jupyter.org/en/latest/_images/other_kernels.png)

Wrapper kernels are easier to write quickly for languages that have good Python wrappers, like [octave_kernel](https://pypi.python.org/pypi/octave_kernel), or languages where it’s impractical to implement the communications machinery, like [bash_kernel](https://pypi.python.org/pypi/bash_kernel). Native kernels are likely to be better maintained by the community using them, like [IJulia](https://github.com/JuliaLang/IJulia.jl) or [IHaskell](https://github.com/gibiansky/IHaskell). Xeus kernels are easy to write when the language interpreter provides a C++ or a C API.
对于具有良好 Python 包装器的语言（如 octave_kernel）或实现通信机制不切实际的语言（如 bash_kernel），包装器内核更容易快速编写。 原生内核可能会由使用它们的社区更好地维护，例如 IJulia 或 IHaskell。 当语言解释器提供 C++ 或 C API 时，Xeus 内核很容易编写。

> See also
> [Making kernels for Jupyter](https://jupyter-client.readthedocs.io/en/latest/kernels.html#kernels "(in jupyter_client v8.2)")
> [Kernels](https://docs.jupyter.org/en/latest/projects/kernels.html#kernels-langs)

## The Jupyter Notebook format

Jupyter Notebooks are structured data that represent your code, metadata, content, and outputs. When saved to disk, the notebook uses the extension `.ipynb`, and uses a JSON structure. For more information about the notebook format structure and specification, see [the nbformat documentation](https://nbformat.readthedocs.io/en/latest/format_description.html).
Jupyter 笔记本是代表您的代码、元数据、内容和输出的结构化数据。 保存到磁盘时，笔记本使用扩展名 .ipynb，并使用 JSON 结构。有关笔记本格式结构和规范的更多信息，请参阅 nbformat 文档。

## The Jupyter Notebook Interface

Jupyter Notebook and its flexible interface extends the notebook beyond code to visualization, multimedia, collaboration, and more. In addition to running your code, it stores code and output, together with markdown notes, in an editable document called a notebook. When you save it, this is sent from your browser to the Jupyter server, which saves it on disk as a JSON file with a `.ipynb` extension.
Jupyter Notebook 及其灵活的界面将笔记本从代码扩展到可视化、多媒体、协作等。 除了运行您的代码，它还将代码和输出连同降价注释一起存储在称为笔记本的可编辑文档中。 当您保存它时，它会从您的浏览器发送到 Jupyter 服务器，该服务器将其作为扩展名为 .ipynb 的 JSON 文件保存在磁盘上。

![](https://docs.jupyter.org/en/latest/_images/notebook_components.png)

The Jupyter server is a communication hub. The browser, notebook file on disk, and kernel cannot talk to each other directly. They communicate through the Jupyter server. The Jupyter server, not the kernel, is responsible for saving and loading notebooks, so you can edit notebooks even if you don’t have the kernel for that language—you just won’t be able to run code. The kernel doesn’t know anything about the notebook document: it just gets sent cells of code to execute when the user runs them.
Jupyter 服务器是一个通信枢纽。 浏览器、磁盘上的笔记本文件和内核不能直接相互对话。 他们通过 Jupyter 服务器进行通信。 负责保存和加载笔记本的是 Jupyter 服务器，而不是内核，因此即使您没有该语言的内核，您也可以编辑笔记本——只是无法运行代码。 内核对笔记本文档一无所知：它只是收到发送的代码单元，以便在用户运行它们时执行。

## Exporting Jupyter Notebooks to other formats

The [Nbconvert tool](https://nbconvert.readthedocs.io/en/latest/index.html "(in nbconvert v7.3)") in Jupyter converts notebook files to other formats, such as HTML, LaTeX, or reStructuredText. This conversion goes through a series of steps:

![](https://docs.jupyter.org/en/latest/_images/nbconvert.png)

1. Preprocessors modify the notebook in memory. E.g. ExecutePreprocessor runs the code in the notebook and updates the output.

2. An exporter converts the notebook to another file format. Most of the exporters use templates for this.

3. Postprocessors work on the file produced by exporting.

The [nbviewer](http://nbviewer.jupyter.org/) website uses nbconvert with the HTML exporter. When you give it a URL, it fetches the notebook from that URL, converts it to HTML, and serves that HTML to you.

### IPython.parallel

IPython also includes a parallel computing framework, [IPython.parallel](https://ipyparallel.readthedocs.io/en/latest/). This allows you to control many individual engines, which are an extended version of the IPython kernel described above.

## JupyterHub and Binder

JupyterHub is a multi-user Hub that spawns, manages, and proxies multiple instances of the single-user Jupyter notebook server. This can be used to serve a variety of interfaces and environments, and can be run on many kinds of infrastructure. JupyterHub on Kubernetes is a Helm Chart for running JupyterHub on kubernetes infrastructure, and BinderHub is a customized JupyterHub deployment for shareable, reproducible interactive computing environments.

The links below describe the architecture of JupyterHub and several distributions of JupyterHub.

- [JupyterHub core architecture](https://jupyterhub.readthedocs.io/en/latest/reference/technical-overview.html "(in JupyterHub)")

- [JupyterHub for Kubernetes architecture](https://z2jh.jupyter.org/en/latest/administrator/architecture.html "(in Zero to JupyterHub with Kubernetes)")

- [BinderHub architecture](https://binderhub.readthedocs.io/en/latest/overview.html#diagram "(in BinderHub)")

## JupyterLab

JupyterLab is a flexible, extensible interface for interactive computing. Below are a few links that are useful for understanding the JupyterLab architecture.

- [JupyterLab document model](https://jupyterlab.readthedocs.io/en/latest/user/documents_kernels.html#kernel-backed-documents "(in JupyterLab v4.0)")

- [JupyterLab notebook model](https://jupyterlab.readthedocs.io/en/latest/user/notebook.html#notebook "(in JupyterLab v4.0)")

- [Design patterns in JupyterLab](https://jupyterlab.readthedocs.io/en/latest/developer/patterns.html "(in JupyterLab v4.0)")
